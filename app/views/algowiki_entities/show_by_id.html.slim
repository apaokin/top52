# coding: utf-8

h4 =  "Performance Data by #{@ent.type_eng} : #{@ent.name}. Sorted by: #{@sort_attr}"
br

= bootstrap_form_tag url: new_results_post_path do |f|
  = f.collection_select :algo_id, AlgowikiEntity.where(is_valid: 1).order(:type_id, :name), :id, :full_name, {include_blank: true, label: "From Algowiki", selected: @ent.id}
  = f.submit "FILTER"
  br
  = f.fields_for :limits do |g|
    br
    = g.fields_for :task_size do |h|
      h4 = "Task size (from #{@ts_bounds[0]} to #{@ts_bounds[1]})"
      = h.number_field :from, label: "from", in: @ts_bounds[0]...@ts_bounds[1] + 1, value: @ts_from
      = h.number_field :to, label: "to", in: @ts_bounds[0]...@ts_bounds[1] + 1, value: @ts_to
      = h.check_box :allow_empty, checked: (@ts_empty != 0), label: "Allow empty"
    br
    = g.collection_select :platform_ids, Top50Machine.where("id in (?) and length(name) > 0 and is_valid = 1", @pl_all).order(:name), :id, :name, {include_blank: true, label: "Platform", selected: @pl_ids}, {multiple: true}
    br
    = g.fields_for :nodes do |h|
      h4 = "Nodes count (from #{@nodes_bounds[0]} to #{@nodes_bounds[1]})"
      = h.number_field :from, label: "from", in: @nodes_bounds[0]...@nodes_bounds[1] + 1, value: @nodes_from
      = h.number_field :to, label: "to", in: @nodes_bounds[0]...@nodes_bounds[1] + 1, value: @nodes_to
    br
    = g.select :launch_types, options_for_select(@lt_all.map { |x| [x.to_s, x.to_s] }, selected: @lt_cur), {include_blank: true, label: "Launch type"}, {multiple: true}
    br
    = g.select :networks, options_for_select(@net_all.map { |x| [x.to_s, x.to_s] }, selected: @net_cur), {include_blank: true, label: "Interconnect family"}, {multiple: true}
  = f.submit "SHOW"
br

table class="table table-responsive table-striped"
  tr
    th
      = "â„–"
    th 
      = "Algorithm"
    th 
      = "Implementation"
    th 
      = "Platform"
    th
      = "Node group"
    th
      = "Specs"
    th
     = "Interconnect"
    th
      = "Is partial?"
    - @cr.launch_attrs.each do |la|
      th 
        = la
  - cur = 0
  - 
  - (@cr.results.reject {|x| should_skip(x)}).each do |res|
	  tr
	  - cur = cur + 1
      td class="col-1"
        = cur
        - impl = AlgoImplementation.find(res[:imp][:id])
        - machine = Top50Machine.find(res[:machine][:id])
        - node_group = res[:node_group]
        - if not node_group[:id].present?
          - node_group = res[:machine]
      td class="col-3"
        = impl.alg.name
      td class="col-3"
        = impl.name
      td class="col-3"
        = machine.name
      td class="col-3"
        = res[:node_group]['Name']
      td class="col-8"
        - node_group[:relations].each do |rel0|
          - if rel0["son_type"] == "Compute node"
            = "#{rel0['count']} x "
            - @cr.rels_by_id(rel0["son_id"], 1).each do |rel1|
              - if rel1["son_type"] == "Compute group"
                = "#{rel1['count']} x"
                br
                - @cr.rels_by_id(rel1["son_id"], 2).each do |rel2|
                  - if rel2["son_type"] == "CPU"
                    - cpu_attrs = @cr.attrs_by_id(rel2["son_id"])
                    = "#{rel2['count']} #{cpu_attrs['CPU Vendor']} #{cpu_attrs['CPU model']}: #{cpu_attrs['Clock frequency (MHz)']}MHz, #{cpu_attrs['Number of cores']} cores, #{cpu_attrs['L2 cache, KB']}KB of L2 cache"
                  - else
                    = "#{rel2['count']} #{rel2['son_type']}"
                  br
      td class="col-3"
        = res[:machine]['Networks'].to_a.join(',')
      td class="col-3"
        = res[:launch][:partial_runs].present? ? "Yes" : "No"
      - @cr.launch_attrs.each do |la| 
        td class="col-3"
          = res[:launch][la]
